---
# yaml-language-server: $schema=./schema_2.json
version: 'example2'
tags:
  - name: "foo"
    continual:
      - existing: { tag: "bar" }
      - linear:
          pattern: '\.(\d+)\.'
          fields:
            1: dot-stopped
      - linear:
          pattern: '\d{\_1}'
          dyn-groups:
            1: val-length
          fields:
            0: len-stopped
    serialization-script: |
      out['dot-stopped'] = tostring(inp['dot-stopped']:as_i32())
      out['len-stopped'] = tostring(inp['len-stopped']:as_i32())
    deserialization-script: |
      out['dot-stopped'] = tonumber(inp['dot-stopped'])
      out['len-stopped'] = tonumber(inp['len-stopped'])

  - name: "bar"
    branched:
      branching-script: |
         branch = inp['is-left']:as_bool() and 0 or 1 
      debranching-script: |
         out['is-left'] = branch == 1
      rules:
        - linear: { pattern: 'left' }
        - linear: { pattern: 'right' }

  - name: "baz"
    branched:
      branching-script: |
        -- error without round brackets
        branch = ({ a = 0, b = 1 })[ctx['type']:as_string()]
      debranching-script: |
        ctx['type'] = ({ 0 = 'a', 1 = 'b' })[branch]
      rules:
        # TODO inline (anonymous) tags
        - existing: { tag: "baz-helper-a" }
        - existing: { tag: "baz-helper-b" }
  - name: "baz-helper-a"
    continual:
      - linear: { pattern: "a*", fields: { 0: letter } }
      # TODO pass fields through without scripts
    serialization-script: |
      out['letter'] = inp['letter']:as_string()
    deserialization-script: |
      out['letter'] = inp['letter']
  - name: "baz-helper-b"
    continual:
      - linear: { pattern: "b*", fields: { 0: letter } }
    serialization-script: |
      out['letter'] = inp['letter']:as_string()
    deserialization-script: |
      out['letter'] = inp['letter']

  - name: "pos"
    continual:
      - linear:
          pattern: '(\d+), (\d+)'
          fields:
            1: x
            2: y
    serialization-script: |
      out['x'] = tostring(inp['x']:as_i32())
      out['y'] = tostring(inp['y']:as_i32())
    deserialization-script: |
      out['x'] = tonumber(inp['x'])
      out['y'] = tonumber(inp['y'])

  - name: "input"
    continual:
      - linear:
          pattern: 'from: \('
      - existing: # existing tag several times (reason of prefix existence)
          tag: "pos"
          prefix: from
      - linear:
          pattern: '\) to: \('
      - existing:
          tag: "pos"
          prefix: to
      - linear:
          pattern: '\)'

  - name: "recursive"
    continual:
      - linear: { pattern: '\[ ' }
      - existing: { tag: "recursive-payload" }
      - linear: { pattern: '-?\d+', fields: { 0: last-element } }
      - linear: { pattern: ' \]' }
    serialization-script: |
      out['last-element'] = tostring(inp['last-element']:as_i32())
    deserialization-script: |
      out['last-element'] = tonumber(inp['last-element'])
  - name: "recursive-payload"
    continual:
      - linear: { pattern: '(-?\d+), ', fields: { 1: element } }
      - existing: { tag: "recursive-payload", prefix: "next", required: false }
    serialization-script: |
      if inp['element'] ~= nil then
        out['element'] = tostring(inp['element']:as_i32())
      end
      -- else do nothing and trigger check in c++ code
    deserialization-script: |
      -- recursion exit?
      out['element'] = tonumber(inp['element'])

  - name: "pos-list"
    continual:
      - linear: { pattern: "[ " }
      - existing: { tag: "pos-list-payload" }
      - linear: { pattern: " ]" }
  - name: "pos-list-payload"
    recurrent:
      - existing: { tag: "pos", priority: 1 }
      - infix: { pattern: ", " }
...