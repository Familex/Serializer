---
# yaml-language-server: $schema=./schema_2.json
version: 'example2'
tags:
  - name: "foo"
    continual:
      - existing: { tag: "bar" }
      - linear:
          pattern: '\.(-?\d+)\.'
          fields:
            1: dot-stopped
      - linear:
          pattern: '-?\d{\_1}'
          dyn-groups:
            1: val-length
          fields:
            0: len-stopped
    serialization-script: |
      out['dot-stopped'] = tostring(inp['dot-stopped']:as_i32())
      local len_stopped_str = tostring(inp['len-stopped']:as_i32())
      local is_neg = inp['len-stopped']:as_i32() < 0
      local len = tonumber(ctx['val-length']:as_string())
      while len_stopped_str:len() < len + (is_neg and 1 or 0) do
        if is_neg then
          -- add '0' after minus sign
          len_stopped_str = len_stopped_str:sub(1, 1) .. '0' .. len_stopped_str:sub(2)
        else
          len_stopped_str = '0' .. len_stopped_str
        end
      end
      out['len-stopped'] = len_stopped_str
    deserialization-script: |
      out['dot-stopped'] = tonumber(inp['dot-stopped'])
      out['len-stopped'] = tonumber(inp['len-stopped'])

  - name: "bar"
    branched:
      branching-script: |
         branch = inp['is-left']:as_bool() and 0 or 1 
      debranching-script: |
         out['is-left'] = branch == 1
      rules:
        - linear: { pattern: 'left' }
        - linear: { pattern: 'right' }

  - name: "baz"
    branched:
      branching-script: |
        -- error without round brackets
        branch = ({ a = 0, b = 1 })[ctx['type']:as_string()]
      debranching-script: |
        ctx['type'] = ({ 0 = 'a', 1 = 'b' })[branch]
      rules:
        # TODO inline (anonymous) tags
        - existing: { tag: "baz-helper-a" }
        - existing: { tag: "baz-helper-b" }
  - name: "baz-helper-a"
    continual:
      - linear: { pattern: "a*", fields: { 0: letter } }
      # TODO pass fields through without scripts
    serialization-script: |
      out['letter'] = inp['letter']:as_string()
    deserialization-script: |
      out['letter'] = inp['letter']
  - name: "baz-helper-b"
    continual:
      - linear: { pattern: "b*", fields: { 0: letter } }
    serialization-script: |
      out['letter'] = inp['letter']:as_string()
    deserialization-script: |
      out['letter'] = inp['letter']

  - name: "pos"
    continual:
      - linear:
          pattern: '(-?\d+), (-?\d+)'
          fields:
            1: x
            2: y
    serialization-script: |
      out['x'] = tostring(inp['x']:as_i32())
      out['y'] = tostring(inp['y']:as_i32())
    deserialization-script: |
      out['x'] = tonumber(inp['x'])
      out['y'] = tonumber(inp['y'])

  - name: "input"
    continual:
      - linear:
          pattern: 'from: \('
      - existing: # existing tag several times (reason of prefix existence)
          tag: "pos"
          prefix: from
      - linear:
          pattern: '\) to: \('
      - existing:
          tag: "pos"
          prefix: to
      - linear:
          pattern: '\)'

  - name: "recursive"
    continual:
      - linear: { pattern: '\[ ' }
      - existing: { tag: "recursive-payload" }
      - linear: { pattern: '-?\d+', fields: { 0: last-element } }
      - linear: { pattern: ' \]' }
    serialization-script: |
      out['last-element'] = tostring(inp['last-element']:as_i32())
    deserialization-script: |
      out['last-element'] = tonumber(inp['last-element'])
  - name: "recursive-payload"
    continual:
      - linear: { pattern: '(-?\d+), ', fields: { 1: element } }
      - existing: { tag: "recursive-payload", prefix: "next", required: false }
    serialization-script: |
      if inp['element'] ~= nil then
        out['element'] = tostring(inp['element']:as_i32())
      end
      -- else do nothing and trigger check in c++ code
    deserialization-script: |
      -- recursion exit?
      out['element'] = tonumber(inp['element'])

  - name: "pos-list"
    continual:
      - linear: { pattern: '\[ ' }
      - existing: { tag: "pos-list-payload" }
      - linear: { pattern: ' \]' }
  - name: "pos-list-payload"
    recurrent:
      - linear: { pattern: '\( ' }
      - existing: { tag: "pos" }
      - linear: { pattern: ' \)' }
      - infix: { pattern: ', ' }

  - name: "pos-list-list"
    continual:
      - linear: { pattern: '\[ ' }
      - existing: { tag: "pos-list-list-payload" }
      - linear: { pattern: ' \]' }
  - name: "pos-list-list-payload"
    recurrent:
      - existing: { tag: "pos-list", priority: 2 }
      - infix: { pattern: ', ' }

  - name: "existing-existing-test"
    continual:
      - linear: { pattern: 'exex: ' }
      - existing: { tag: "existing-test" }
  - name: "existing-test"
    continual:
      - linear: { pattern: 'ex: ' }
      - existing: { tag: "existing-test-payload" }
  - name: "existing-test-payload"
    continual:
      - linear: { pattern: 'existing-test-data' }
...